---
title: 5.1 Transformer横空出世
description: 2017 年，Google Brain 团队发表的论文《Attention Is All You Need》彻底改变了序列建模领域，正式推出了 Transformer 架构。该架构完全摒弃了传统的循环网络（RNN），仅依赖于“自注意力机制”。通过多头注意力和位置编码等创新设计，Transformer 不仅能捕捉长距离依赖关系，更重要的是实现了完全并行计算，极大地提升了训练效率和模型性能，开启了大规模预训练模型的新纪元。
---

构建一个完全基于注意力机制的神经网络架构？

这个看似大胆的想法，最终催生了改变深度学习格局的 Transformer 架构。

这个全新的架构不仅突破了 RNN 的串行限制，实现了前所未有的并行计算效率。

更重要的是，它还开启了一个全新的时代——**预训练大模型时代**。

2017 年，Google Brain 团队发表了一篇标题简洁却意义深远的论文 —— [注意力就是全部所需（Attention Is All You Need）](https://papers.nips.cc/paper_files/paper/2017/hash/3f5ee243547dee91fbd053c1c4a845aa-Abstract.html)。这篇论文不仅提出了 Transformer 架构，更引发了一场席卷整个AI领域的技术革命。

当时的主流序列建模方法都是基于RNN的，即使是最先进的 LSTM 和 GRU（LSTM的简化版），也无法完全摆脱串行计算的桎梏。注意力机制虽然有效，但仍然只是 RNN 的辅助工具。而 Google Brain 团队则是完全抛弃RNN，仅使用注意力机制来构建序列模型，它就是 Transformer。

## 5.1.1 自注意力

传统的注意力机制是在**编码器/解码器**架构中，让解码器“关注”编码器的输出。但 Transformer 提出了一个更加激进的概念：**自注意力（Self-Attention）**。

什么是自注意力？用一个生活化的例子来解释：

想象你在阅读这样一个句子：“小明很聪明，他总是能够快速理解复杂的数学问题。”

当你看到“他”这个词时，你的大脑会自动将“他”与前面的“小明”联系起来。这种联系不需要外部提示，而是基于对整个句子的理解自然产生的。

自注意力机制就是让机器学会这种“自我关联”的能力。对于输入序列中的每个位置，自注意力都会计算它与序列中所有其他位置的关联度，包括它自己。

想要理解也非常简单，我们以“小明很聪明”为例，看看自注意力是如何工作的。

首选第一步，生成 Query、Key、Value 向量。

对于句子中的每隔词，Transformer 都会生成三个向量：

- **Query（查询）：** 表示“我想找什么信息”
- **Key（键）：** 表示“我能提供什么信息”
- **Value（值）：** 表示“我的实际信息内容”

对于“小明很聪明”这句话：

```
句子: "小明 很 聪明"

小明: Query₁, Key₁, Value₁
很:   Query₂, Key₂, Value₂  
聪明: Query₃, Key₃, Value₃
```

接着第二步，计算注意力分数。

对于每个词，用它的 Query 向量与所有词（包括自己）的 Key 向量计算相似度：

```
处理"小明"时：
- Query₁ × Key₁ = 8.2  (小明关注小明自己)
- Query₁ × Key₂ = 3.1  (小明关注"很")
- Query₁ × Key₃ = 5.7  (小明关注"聪明")

处理"很"时：
- Query₂ × Key₁ = 4.5  ("很"关注"小明")
- Query₂ × Key₂ = 6.8  ("很"关注自己)
- Query₂ × Key₃ = 9.3  ("很"关注"聪明")

处理"聪明"时：
- Query₃ × Key₁ = 7.4  ("聪明"关注"小明")
- Query₃ × Key₂ = 8.9  ("聪明"关注"很")
- Query₃ × Key₃ = 9.1  ("聪明"关注自己)
```

然后是第三步，转换为注意力权重。

使用 softmax 函数将注意力分数转换为权重，即归一化：

```
"小明"的注意力分布:
- 对自己: 0.48 (48%)
- 对"很": 0.18 (18%)  
- 对"聪明": 0.34 (34%)

"很"的注意力分布:
- 对"小明": 0.22 (22%)
- 对自己: 0.31 (31%)
- 对"聪明": 0.47 (47%)

"聪明"的注意力分布:
- 对"小明": 0.35 (35%)
- 对"很": 0.39 (39%)
- 对自己: 0.41 (41%)
```

最后第四步，进行加权求和生成输出。

根据注意力权重对 Value 向量进行加权求和：

```
"小明"的输出表示 = 0.48×Value₁ + 0.18×Value₂ + 0.34×Value₃
"很"的输出表示   = 0.22×Value₁ + 0.31×Value₂ + 0.47×Value₃
"聪明"的输出表示 = 0.35×Value₁ + 0.39×Value₂ + 0.41×Value₃
```

这样，每个词的最终表示都融合了整个序列的信息，而且这种融合是基于语义相关性自动计算的。简单来说，就是每个词最终的输出其实是基于所有词的相关性信息自动计算得来的（如图 5-1）。

![图 5-1 基于Self-Attention的词（小明）输入到输出流程](https://cdn.isboyjc.com/ai-evolution/1756138943036.png)



## 5.1.2 多头注意力

光有一种注意力模式还不够。人类在理解语言时会同时关注多个方面：语法关系、语义联系、情感色彩等。Transformer 通过 **多头注意力（Multi-Head Attention）** 来模拟这种能力。

简单来说，多头注意力就是并行运行多个自注意力机制，每个“头”都有自己的 Query、Key、Value 变换矩阵，可以学习不同类型的关联模式：

- 第 1 个头：可能专注于语法关系（主谓宾结构）
- 第 2 个头：可能专注于语义相关性
- 第 3 个头：可能专注于时间或逻辑顺序
- 第 4 个头：可能专注于情感或态度表达
- …

最终所有的头输出会被拼接统一处理，形成一个更丰富的表示，还是拿“小明很聪明”来看，假设我们使用双头注意力，词的输入到输出流程也很好理解（如图 5-2）。

![图 5-2 基于Multi-Head Attention的词（小明）输入到输出流程（双头，图中省略了“聪明”即$$x_3$$输入）](https://cdn.isboyjc.com/ai-evolution/1756138977158.png)


## 5.1.3 位置编码

我们知道 RNN 天然具有位置感知能力，因为它按顺序处理输入。但自注意力机制本身是位置无关的——它只关心词与词之间的相关性，不关心它们的先后顺序。

那么完全抛弃 RNN 后，Transformer 面临一个关键问题：如何让模型感知词语的位置信息？

如果没有位置信息，“小明喜欢小红”和“小红喜欢小明”对模型来说就没有区别，这显然是不对的。

Transformer 的解决方案是位置编码（Positional Encoding）：为每个位置生成一个独特的编码，并将其加到词向量上。

```
原始词向量: "小明"的向量 + 位置1的编码 = 带位置信息的"小明"表示
          "喜欢"的向量 + 位置2的编码 = 带位置信息的"喜欢"表示
          "小红"的向量 + 位置3的编码 = 带位置信息的"小红"表示
```

这样，即使是相同的词在不同位置，也会有不同的表示，模型就能区分“小明喜欢小红”和“小红喜欢小明”了（如图 5-3）。

![图 5-3 添加位置编码 e](https://cdn.isboyjc.com/ai-evolution/1756139036632.png)


## 5.1.4 架构优势

Transformer 的这种设计带来了革命性的优势，可以说是集合了 RNN 和 CNN 的所有优点。

**完全并行化**

它不像 RNN 需要等待前一个时间步完成，Transformer 可以同时计算所有位置的注意力。对于一个长度为 100 的序列，RNN 需要 100 个串行步骤，而 Transformer 只需要 1 个并行步骤。没错，GPU 的并行计算能力得到了充分释放。

**长距离依赖**

自注意力机制让每个位置都能直接关注到序列中的任何其他位置，不像 RNN 需要通过多个时间步来传递长距离信息。

**可解释性**

注意力权重为我们提供了模型决策的直观解释，我们可以看到模型在处理每个词时关注了哪些其他词。

**灵活的架构**

Transformer 的 **编码器-解码器** 结构非常灵活，可以根据不同任务进行调整。


## 5.1.5 新时代的开启

当 Transformer 在机器翻译任务上进行测试时，结果令人震惊。无论是评分还是性能，几乎都是碾压式胜利。

更重要的是，由于使用 GPU 并行计算能力，Transformer 的训练速度快了一个数量级。在相同的硬件配置下，RNN 模型需要训练几周的任务，Transformer 只需要几天就能完成。可以说是一个颠覆性的突破。

Transformer 架构不仅仅是一个解决了 RNN 问题的技术改进，毫不夸张的说，它开启了一个新的时代——大规模预训练大模型时代。