---
title: 7.3 模型上下文协议（MCP）
description: 为解决各家大模型Function Calling接口不统一的问题，MCP应运而生。作为一个开放标准，MCP规范了模型与外部工具、数据源之间的交互方式，使得开发者可以“一次开发，到处运行”工具服务（MCP Server）。这大大降低了多模型适配的复杂性，促进了一个可互操作的AI工具生态系统的形成，其定位类似于硬件领域的USB标准。
---

就像早期的电脑接口各不相同，直到USB标准的出现才统一了设备连接方式一样。大模型的外部交互能力也需要统一。2024年底Claude母公司Anthropic发布了**模型上下文协议（Model Context Protocol，MCP）**，它正是为了解决这个问题而诞生的。


## 7.3.1 什么是MCP？

MCP是一个开放协议，它规范了应用程序向LLM提供上下文的方式。正如USB-C提供了一种标准化的方式将您的设备连接到各种外围设备和配件一样，MCP也提供了一种标准化的方式将AI模型连接到不同的数据源和工具。

简单来说，MCP是为“模型-外部系统”之间的数据交互建立的一种统一上下文协议层，让模型不仅能“看懂”用户输入，还能"理解"环境状态、会话历史、工具链信息，甚至主动“做事”。

## 7.3.2 MCP工作原理

MCP由三个部分构成：

- **MCP Host：** 主机或者说连接大模型的应用程序，负责协调各模块、维护统一的上下文状态（比如Cursor、Cline、Claude Desktop等）
- **MCP Client：** 作为应用程序的接入点，负责将用户请求转换为标准MCP格式与MCP Server通信
- **MCP Server：** 作为服务模块，提供上下文、工具和提示，处理来自Client的请求并返回标准化的响应

它们之间的关系（如图7-5）

![图7-5 MCP组成架构](https://cdn.isboyjc.com/ai-evolution/1756139240243.png)

一个用于与大模型对话并支持MCP的应用程序，我们就可以称之为Host（本节中的应用程序未特殊说明均指的是Host）。

应用程序中的MCP Client负责与MCP Server通信。

而MCP Server，我们可以将它理解为一个服务，它可以提供资源（Resources）、提示词（Prompts）、工具（Tools）等。

- **资源（Resources）：** 指的是可由MCP Client读取并用作大模型交互上下文的一组数据或内容。
- **提示词（Prompts）：** 指的是可由MCP Client读取并用作大模型交互上下文的一组提示词模板。
- **工具（Tools）：** 指的是可由MCP Client读取并可以被调用执行的外部工具（可以理解为函数）。

当然，我们这里着重介绍Tools，这也是大多数人会关注的点。

假如我们开发了一个名字叫weather的MCP Server，它有两个Tool，即两个工具函数：

- get_weather(location,date)：获取天气方法 
  - location：地点
  - date：时间
- get_current_date()：获取当前时间

针对MCP Server，我们可以在本地启动一个MCP Server，通过标准输入输出也就是stdio模式与我们要使用的支持MCP Client的产品通信，也可以使用SSE模式直接输入一个MCP Server链接以HTTP协议与我们要使用的支持MCP Client的产品通信。具体的使用可以参考各个应用程序的MCP Server配置文档。

当我们把这个MCP Server配置到应用程序中时（以Claude Desktop为例），Claude Desktop中的MCP Client会尝试给这个MCP Server发送质询，如图7-6。

![图7-6 MCP Client质询流程](https://cdn.isboyjc.com/ai-evolution/1756139264308.png)

整个质询流程结束后，MCP Client就已经就绪了，它已经知道并记录了MCP Server所有能力，落实到程序中，其实就是Client向Server发送一段标准JSON Schema，Server收到后回复Client一段标准JSON Schema。注意，这整个流程发生在用户发送问题之前的准备阶段，即打开Claude Desktop时或者是在Claude Desktop中新添加一个MCP Server时。

当用户在Claude Desktop中发送”北京今天天气“时：

- 首先Claude Desktop会将问题描述和当前所有MCP Server Tools的信息一起发送给大模型。
- 大模型觉得需要调用get_current_date获取今天的日期才行，于是解析get_current_date的Tool名、参数等信息发送给Claude Desktop
- Claude Desktop接收到调用get_current_date的信号后，其MCP Client会将调用信息发送给对应的MCP Server执行并拿到返回结果（2025-06-24）
- Claude Desktop会将原始问题、get_current_date返回结果、MCP Server Tools信息再次发送大模型
- 大模型觉得还需要调用get_weather获取天气，于是解析get_weather的信息，将Tool名、参数（地点北京、时间2025-06-24）发给Claude Desktop
- Claude Desktop接收到调用get_weather的信号后，其MCP Client会将调用信息发送给对应的MCP Server执行并拿到返回结果
- 还是重复的流程，Claude Desktop会将原始问题、历史信息、get_weather返回结果再次发送大模型
- 大模型收到后回复”今天是2025-06-23日，北京天气阴转晴“，再由Claude Desktop展现给用户

整个示例的MCP流程（如图7-7）。

![图7-7 MCP调用流程](https://cdn.isboyjc.com/ai-evolution/1756139299727.png)

在整个交互流程中MCP协议仅作用于MCP Client和MCP Server之间，而是否调用、调用哪个MCP Server中的Tool，取决于大模型的自主决策，这并不在MCP协议的范围内。

所以我们可以说MCP和大模型没有直接关系，它是一个处于大模型上层的协议，通过大模型的自主决策去选择调用。大模型收到MCP Server传递的丰富上下文（包含Tool列表、环境状态、用户输入等）后，会基于自身理解做出两类决策：

- 仅生成文本回复：若判断当前任务不需要调用外部工具，模型直接回复自然语言内容
- 生成Tool调用意图：若模型认为需要“行动”才能满足用户需求，它会生成标准化的Tool调用请求

这种调用意图是大模型基于上下文自主形成的，不同模型可能有不同的“行动偏好”，但MCP规范了其输出格式，基于标准输出格式就确保了MCP Client可以正确向MCP Server发送调用请求。

不同的应用程序，比如Cursor、Claude Desktop、Cline它们在处理大模型调用MCP Server的方式各不相同，最简单的就是靠提示词约束大模型的调用意图，甚至还可以通过Function Calling机制来实现大模型的Tool调用输出。

## 7.3.3 Function Calling VS MCP

虽然Function Calling和MCP从表面上看，都是让大模型“具备行动能力”，但它们的定位、作用、技术架构完全不同。

Function Calling是一种大模型根据上下文自动选择调用并执行函数的机制。不同的模型厂商有不同的Function Calling实现，代码集成的方式也不一样，开发者需要考虑如何将函数暴露给大模型去调用。当我们想要为一个AI应用集成一些外部能力时，使用Function Calling需要我们为之开发一个个功能函数，尽管这些功能函数非常普遍我们依然要去重复造这个“轮子”。

但MCP不同，它是一个统一的标准，我们只需要按照MCP标准规范去开发MCP Server，那么所有支持MCP Client的Host或者说应用程序，都可以去调用这个MCP Server，真正做到了一次开发一劳永逸。当我们开发一个AI应用时，想要集成一些外部能力，甚至可以不去开发MCP Server，只需要支持MCP Client，市面上所有的开源MCP Server都可以接入进来。

如果大家都认可并且遵循这个规范，那么第三方只需要按照标准规范提供MCP Server就可以接入所有支持MCP Client的大模型或者说应用程序，标准统一的情况下，MCP Server可以遇见的会越来越多，只要有足够多的MCP Server，理论上大模型可以调用一切，与数据、文件系统、开发工具、Web浏览器自动化、生产力工具等各种生态集成，实现强大的协作能力，它的价值不可估量，所以MCP异常火爆。

当然，这并不代表Function Calling就没用了，Function Calling和MCP属于不同层面的东西，在使用MCP的同时，依然可以配合Function Calling去使用。应用可以选择在MCP之上通过Function Calling与模型交互，也可以在MCP范式下使用其他不基于Function Calling的方式与模型或数据源交互。

简单来说，MCP与Function Call是两条并行的赛道，它们不互为前提条件，可以各取所需。